[
    {
        "id": "cf2c675f8061347b",
        "type": "tab",
        "label": "Influx_Data_Pipeline_v1.2",
        "disabled": false,
        "info": "**Description:** End-to-end IO-Link ingestion pipeline that polls gateways over HTTP, parses MQTT telemetry, and writes structured points into InfluxDB.\n**Inputs:** Scheduled inject nodes for HTTP polling, MQTT subscriptions for live traffic, and configuration files loaded on startup.\n**Outputs:** Structured measurements routed to InfluxDB plus mirrored debug logs on disk for traceability.\n**Usage Notes:** Use the grouped swimlanes to understand responsibilities (HTTP polling, MQTT routing, logging). Update context loaders before deploying new mappings.",
        "env": []
    },
    {
        "id": "30ecd298364bec85",
        "type": "group",
        "z": "cf2c675f8061347b",
        "style": {
            "stroke": "#999999",
            "stroke-opacity": "1",
            "fill": "none",
            "fill-opacity": "1",
            "label": true,
            "label-position": "nw",
            "color": "#a4a4a4"
        },
        "nodes": [
            "55a97baa1df66b2d",
            "8c7c9f588c43b1cc",
            "c462826f6ba56b05",
            "0b8152f986cc3aee",
            "04eaeab3954ed85b",
            "763043855486292d",
            "bfaa229223513b0a",
            "9d03019ea3347369"
        ],
        "x": 54,
        "y": 839,
        "w": 1232,
        "h": 229.5
    },
    {
        "id": "6bd2050295ba993d",
        "type": "group",
        "z": "cf2c675f8061347b",
        "style": {
            "stroke": "#999999",
            "stroke-opacity": "1",
            "fill": "none",
            "fill-opacity": "1",
            "label": true,
            "label-position": "nw",
            "color": "#a4a4a4"
        },
        "nodes": [
            "726e078392dc6661",
            "45fe23c1743f8061",
            "0273fa386257d86f",
            "6d31ed85854d0d21",
            "adee3a7bbf45528f",
            "2ac727f19d830d9e",
            "07adc65d2bd0b02c",
            "injectLoad",
            "readFile",
            "parseJSON",
            "storeGlobal",
            "43099c37e53f94c1",
            "cab45e0aedc11ecb",
            "23be7c7ce3851001"
        ],
        "x": 54,
        "y": 39,
        "w": 1832,
        "h": 222
    },
    {
        "id": "59c49ae82eea4453",
        "type": "group",
        "z": "cf2c675f8061347b",
        "style": {
            "stroke": "#999999",
            "stroke-opacity": "1",
            "fill": "none",
            "fill-opacity": "1",
            "label": true,
            "label-position": "nw",
            "color": "#a4a4a4"
        },
        "nodes": [
            "94c4b64fe48bf7a9",
            "8eaae0548f6f1ac0",
            "b9e806b2050cdbc1",
            "fdce59a9bc71b2ec",
            "4561984a904805be",
            "64754fb1bd63425a",
            "68bd7524f18bb41d"
        ],
        "x": 54,
        "y": 299,
        "w": 1372,
        "h": 162
    },
    {
        "id": "d82d2374fafffe60",
        "type": "group",
        "z": "cf2c675f8061347b",
        "style": {
            "stroke": "#999999",
            "stroke-opacity": "1",
            "fill": "none",
            "fill-opacity": "1",
            "label": true,
            "label-position": "nw",
            "color": "#a4a4a4"
        },
        "nodes": [
            "9b8227a1903ea259",
            "8fa862cf2b5615e5",
            "b0c120bd5e993542",
            "71be59b7c2d5a7bb",
            "1f1c7025f2a3ce1c",
            "5fbc78e027f42a44",
            "17bdca1c684de37f",
            "ed545088864a6cb0",
            "27d6194124762096",
            "ea423b52b1e9b387",
            "37d1b98dd92fd5d8",
            "64b71e04aa8a1a66",
            "22361c21b043030f",
            "f5ac08b67bcbd3f4",
            "818bedb30d9efcc5",
            "2cf6872e1b3ad487",
            "e4624ef9b4a1d94b",
            "4adb3d0d2a6e026e",
            "00df87db84b78811",
            "79356ea0aadc9a91",
            "70a12dada24e2da5",
            "78b2a95148c008a2",
            "ef8a0a0990524f77",
            "3443c80672c5e636",
            "2bd8aa8546924e19",
            "2a62ca5551eb6109",
            "713a0f9a472d65ca",
            "13fd02c9973d8e8b",
            "2766c1795827424a",
            "e223c50d5c721039"
        ],
        "x": 54,
        "y": 1119,
        "w": 1372,
        "h": 602
    },
    {
        "id": "b985c3ba5e5519d9",
        "type": "group",
        "z": "cf2c675f8061347b",
        "style": {
            "stroke": "#999999",
            "stroke-opacity": "1",
            "fill": "none",
            "fill-opacity": "1",
            "label": true,
            "label-position": "nw",
            "color": "#a4a4a4"
        },
        "nodes": [
            "820eca120de9c8dc",
            "b580f3c166ef8dda",
            "020cd237371f7f2d",
            "88d0db573e750331",
            "d6ed388d600d8ec0",
            "5228d7f553f62aef",
            "b773ec8167ad6eac",
            "eebe93151283d1c7",
            "7010792667254c11",
            "98cb5aedb10e2562",
            "687557aee3e668df",
            "b7533422c67034ea",
            "152b94b2cb4c6c3a",
            "e34aa1f071f6d44f",
            "e2930e5ebe425c46",
            "d320d8d3aff09585",
            "06c17a95883f1b43"
        ],
        "x": 54,
        "y": 499,
        "w": 1192,
        "h": 302
    },
    {
        "id": "726e078392dc6661",
        "type": "inject",
        "z": "cf2c675f8061347b",
        "g": "6bd2050295ba993d",
        "name": "trigger",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "60",
        "crontab": "",
        "once": true,
        "onceDelay": "5",
        "topic": "",
        "payload": "",
        "payloadType": "str",
        "x": 160,
        "y": 220,
        "wires": [
            [
                "45fe23c1743f8061"
            ]
        ],
        "info": "**Description:** Periodically kicks off the gateway event poller by emitting a blank trigger into *generate IPs*.\n**Inputs:** None; fires automatically once five seconds after deploy and every 60 seconds thereafter.\n**Outputs:** Sends an empty message to the IP generator so each configured gateway is polled for events.\n**Usage Notes:** Adjust the repeat interval to tune HTTP load. Disable when doing manual polling to avoid overlapping requests."
    },
    {
        "id": "45fe23c1743f8061",
        "type": "function",
        "z": "cf2c675f8061347b",
        "g": "6bd2050295ba993d",
        "name": "generate IPs",
        "func": "/**\n * Build a list of gateway IP addresses for downstream polling.\n * - Supports individual hosts via `host`\n * - Supports numeric ranges via `start` and `end`\n * - Emits one message per IP with both `msg.payload` and `msg.ip` populated\n */\nconst ranges = [\n    { base: '192.168.1', start: 111, end: 130 }\n];\n\n// Guard against a missing configuration so the runtime stays quiet\nif (!Array.isArray(ranges) || ranges.length === 0) {\n    node.warn('No IP ranges configured; skipping poll trigger.');\n    return [[]];\n}\n\nconst ips = []; // collected Node-RED messages\n\nfor (const range of ranges) {\n    // Handle explicit host definitions (single addresses)\n    if (range.host !== undefined) {\n        const ip = `${range.base}.${range.host}`;\n        ips.push({ payload: ip, ip });\n        continue;\n    }\n\n    // Handle numeric ranges; reject malformed values gracefully\n    if (range.start !== undefined && range.end !== undefined) {\n        const start = Number(range.start);\n        const end = Number(range.end);\n        if (Number.isFinite(start) && Number.isFinite(end) && end >= start) {\n            for (let i = start; i <= end; i++) {\n                const ip = `${range.base}.${i}`;\n                ips.push({ payload: ip, ip });\n            }\n        } else {\n            node.warn(`Skipping invalid range definition: ${JSON.stringify(range)}`);\n        }\n        continue;\n    }\n\n    // Anything without host/start/end is ignored but surfaced for debugging\n    node.warn(`Skipping entry without host or range: ${JSON.stringify(range)}`);\n}\n\nif (ips.length === 0) {\n    node.warn('Configured ranges produced no addresses; verify host boundaries.');\n}\n\nreturn [ips];\n",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 370,
        "y": 220,
        "wires": [
            [
                "0273fa386257d86f"
            ]
        ],
        "info": "**Description:** Generates one message per gateway IP for the event polling loop.\n**Inputs:** Receives an empty trigger message.\n**Outputs:** Emits an array of messages, each carrying an IP in `msg.payload` and `msg.ip`.\n**Usage Notes:** Edit the `ranges` array inside the function to add or remove gateways. Use single-host entries for isolated devices."
    },
    {
        "id": "0273fa386257d86f",
        "type": "function",
        "z": "cf2c675f8061347b",
        "g": "6bd2050295ba993d",
        "name": "build HTTP URL",
        "func": "// Construct the polling URL for gateway events and keep the source IP handy\nconst basePath = '/iolink/v1/gateway/events';\nconst protocol = 'http';\n\n// Normalise the IP string and guard against missing data\nconst ip = (typeof msg.payload === 'string' ? msg.payload : '').trim();\nif (!ip) {\n    node.warn('Missing IP in payload; HTTP request skipped.');\n    return null;\n}\n\n// Warn (but continue) when the payload does not resemble an IPv4 address\nif (!/^\\d{1,3}(\\.\\d{1,3}){3}$/.test(ip)) {\n    node.warn(`IP payload \"${ip}\" does not look like IPv4; continuing anyway.`);\n}\n\nmsg.url = `${protocol}://${ip}${basePath}`;\nmsg.ip = msg.ip || ip; // ensure downstream nodes can still identify the gateway\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 560,
        "y": 220,
        "wires": [
            [
                "6d31ed85854d0d21",
                "820eca120de9c8dc"
            ]
        ],
        "info": "**Description:** Builds the HTTP URL used to collect gateway event streams.\n**Inputs:** Expects `msg.payload` to contain an IPv4 address from the generator.\n**Outputs:** Sets `msg.url` with the polling endpoint and forwards the message to the HTTP request node.\n**Usage Notes:** Update the base path or protocol in the function body if the gateway firmware changes its API surface."
    },
    {
        "id": "6d31ed85854d0d21",
        "type": "http request",
        "z": "cf2c675f8061347b",
        "g": "6bd2050295ba993d",
        "name": "GET gateway events",
        "method": "GET",
        "ret": "obj",
        "paytoqs": "ignore",
        "url": "",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": true,
        "headers": [],
        "x": 780,
        "y": 220,
        "wires": [
            [
                "adee3a7bbf45528f",
                "5228d7f553f62aef"
            ]
        ],
        "info": "**Description:** Issues the GET request that retrieves `iolink/v1/gateway/events` for each configured gateway.\n**Inputs:** Uses `msg.url` from the URL builder; inherits credentials from Node-RED environment if configured.\n**Outputs:** Routes the HTTP response to both the enrichment function and the debug serializer.\n**Usage Notes:** Configure timeout/retry behaviour in the node settings if gateways are slow to respond."
    },
    {
        "id": "adee3a7bbf45528f",
        "type": "function",
        "z": "cf2c675f8061347b",
        "g": "6bd2050295ba993d",
        "name": "tag IP to payload / error handling",
        "func": "// Ensure the response looks healthy before forwarding it downstream\nconst status = Number(msg.statusCode);\nconst hasPayload = msg.payload !== undefined && msg.payload !== null;\n\n// Treat 4xx/5xx responses as failures\nif (Number.isFinite(status) && status >= 400) {\n    node.warn(`HTTP ${status} from ${msg.ip || msg.payload || 'unknown gateway'} \u2013 dropping message.`);\n    return null;\n}\n\n// Guard against empty payloads that would break later parsing\nif (!hasPayload) {\n    node.warn(`Empty payload received from ${msg.ip || 'unknown gateway'} \u2013 dropping message.`);\n    return null;\n}\n\n// Preserve the originating IP for later enrichment\nmsg.ip = msg.ip || (msg.payload && msg.payload.ip) || null;\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1050,
        "y": 220,
        "wires": [
            [
                "2ac727f19d830d9e",
                "eebe93151283d1c7"
            ]
        ],
        "info": "**Description:** Validates HTTP responses and attaches the originating IP for downstream enrichment.\n**Inputs:** Receives the raw HTTP response from the request node.\n**Outputs:** Passes successful payloads to the array splitter and diverts failures to the logging stream.\n**Usage Notes:** Review the function comments for edge-case handling; extend the warning to include more diagnostics if needed."
    },
    {
        "id": "2ac727f19d830d9e",
        "type": "split",
        "z": "cf2c675f8061347b",
        "g": "6bd2050295ba993d",
        "name": "split events array",
        "splt": "",
        "spltType": "str",
        "arraySplt": "1",
        "stream": false,
        "addname": "",
        "x": 1310,
        "y": 220,
        "wires": [
            [
                "43099c37e53f94c1",
                "98cb5aedb10e2562"
            ]
        ],
        "info": "**Description:** Splits the gateway event array into individual messages for granular processing.\n**Inputs:** Expects `msg.payload` to be an array of events produced by the gateway.\n**Outputs:** Emits one message per event towards the Influx preparation node and the debug serializer.\n**Usage Notes:** Adjust the split mode if the gateway schema changes (e.g., switch to streaming)."
    },
    {
        "id": "07adc65d2bd0b02c",
        "type": "influxdb out",
        "z": "cf2c675f8061347b",
        "g": "6bd2050295ba993d",
        "influxdb": "28500336b4ee8595",
        "name": "Influx - gateway_events",
        "measurement": "gateway_events",
        "precision": "",
        "retentionPolicy": "",
        "database": "",
        "precisionV18FluxV20": "ms",
        "retentionPolicyV18Flux": "",
        "org": "ADTA",
        "bucket": "iot_events",
        "x": 1750,
        "y": 220,
        "wires": [],
        "info": "**Description:** Persists processed gateway events into InfluxDB (bucket `iot_events`, measurement `gateway_events`).\n**Inputs:** Accepts measurement objects produced by *Influx data prep*.\n**Outputs:** None within the flow; writes directly to InfluxDB.\n**Usage Notes:** Confirm the configured organization, bucket, and precision before deploying to a new environment."
    },
    {
        "id": "55a97baa1df66b2d",
        "type": "inject",
        "z": "cf2c675f8061347b",
        "g": "30ecd298364bec85",
        "name": "Load masterMap.json on start",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": true,
        "onceDelay": "0.1",
        "topic": "",
        "payload": "",
        "payloadType": "str",
        "x": 230,
        "y": 960,
        "wires": [
            [
                "8c7c9f588c43b1cc"
            ]
        ],
        "info": "**Description:** Bootstraps the flow context with the IO-Link master configuration map.\n**Inputs:** Fires once at startup; no external trigger required.\n**Outputs:** Passes an empty payload into *Read config JSON* to load `config/masterMap.json`.\n**Usage Notes:** Ensure the JSON file exists before deploying or the downstream parser will fail. Re-trigger manually after updating the configuration file."
    },
    {
        "id": "8c7c9f588c43b1cc",
        "type": "file in",
        "z": "cf2c675f8061347b",
        "g": "30ecd298364bec85",
        "name": "Read config JSON",
        "filename": "config/masterMap.json",
        "filenameType": "str",
        "format": "utf8",
        "chunk": false,
        "sendError": false,
        "encoding": "none",
        "allProps": false,
        "x": 490,
        "y": 960,
        "wires": [
            [
                "c462826f6ba56b05"
            ]
        ],
        "info": "**Description:** Reads the IO-Link master configuration JSON from disk.\n**Inputs:** Triggered by the startup inject node.\n**Outputs:** Emits the file contents as a UTF-8 string to the JSON parser.\n**Usage Notes:** Update `config/masterMap.json` to point to new masters; ensure the file path resolves relative to the Node-RED project."
    },
    {
        "id": "c462826f6ba56b05",
        "type": "json",
        "z": "cf2c675f8061347b",
        "g": "30ecd298364bec85",
        "name": "parse",
        "property": "payload",
        "action": "obj",
        "pretty": false,
        "x": 670,
        "y": 960,
        "wires": [
            [
                "0b8152f986cc3aee"
            ]
        ],
        "info": "**Description:** Converts the master configuration JSON string into a JavaScript object.\n**Inputs:** Expects `msg.payload` to contain raw JSON text.\n**Outputs:** Emits the parsed object to the context storage function.\n**Usage Notes:** Leave `property` as `payload` unless upstream nodes change the message shape."
    },
    {
        "id": "0b8152f986cc3aee",
        "type": "function",
        "z": "cf2c675f8061347b",
        "g": "30ecd298364bec85",
        "name": "save cfg -> flow",
        "func": "// Persist the configuration in flow context so other nodes can reuse it\nconst cfg = msg.payload;\nif (typeof cfg !== 'object' || cfg === null) {\n    node.warn(`Expected configuration object but received ${typeof cfg}.`);\n    return null;\n}\n\nflow.set('cfg', cfg);\nreturn null;\n",
        "outputs": 0,
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 840,
        "y": 960,
        "wires": [],
        "info": "**Description:** Caches the parsed master configuration in flow context under `cfg`.\n**Inputs:** Receives the parsed configuration object.\n**Outputs:** Returns no message; state is stored for later lookups.\n**Usage Notes:** Inspect this node if event routing fails\u2014`cfg` must be loaded before MQTT messages arrive."
    },
    {
        "id": "04eaeab3954ed85b",
        "type": "mqtt in",
        "z": "cf2c675f8061347b",
        "g": "30ecd298364bec85",
        "name": "All IO-Link topics",
        "topic": "+/iolink/v1/#",
        "qos": "1",
        "datatype": "json",
        "broker": "mqtt-broker-local",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 0,
        "x": 180,
        "y": 1020,
        "wires": [
            [
                "763043855486292d",
                "4adb3d0d2a6e026e",
                "79356ea0aadc9a91"
            ]
        ],
        "info": "**Description:** Subscribes to all IO-Link MQTT topics published by the gateways.\n**Inputs:** No flow input; listens on broker topic `+/iolink/v1/#`.\n**Outputs:** Broadcasts each MQTT message to the router, raw-frame logger, and raw-input file sink.\n**Usage Notes:** Adjust QoS or topic filter to limit traffic when debugging."
    },
    {
        "id": "763043855486292d",
        "type": "function",
        "z": "cf2c675f8061347b",
        "g": "30ecd298364bec85",
        "name": "IO-Link router",
        "func": "/**\n * IO-Link router \u2013 v10 (2025-06-09)\n * \u2022 Supports classic ports/* & devices/masterNportM topics\n * \u2022 Flattens getData & setData\n * \u2022 Now handles:\n *     \u2013 diagnostics, statistics, processdata, identification, capabilities\n *     \u2013 configuration (port & gateway)\n *     \u2013 events (one message per event)\n * \u2022 Output contract:\n *     0 \u279c Influx points\n *     1 \u279c accepted raw frame\n *     2 \u279c discarded frame (+ msg.reason & msg.routerTime)\n */\n\nconst cfg = flow.get(\"cfg\");\n// 1. Load and validate configuration from flow context\n//    \u2022 `cfg` must exist and contain your alias mappings\n//    \u2022 If not loaded, route frame to output 2 with reason and timestamp\nif (!cfg) {\n  msg.reason     = \"cfg not loaded yet\";\n  msg.routerTime = new Date().toISOString();\n  // Outputs: [InfluxPoints, AcceptedRaw, Discarded]\n  return [null, null, msg];\n}\n// 2. Ensure incoming payload is an object\nif (typeof msg.payload !== \"object\" || msg.payload === null) {\n  msg.reason     = \"payload not an object\";\n  msg.routerTime = new Date().toISOString();\n  return [null, null, msg];\n}\n\n// \u2500\u2500 Topic parsing \u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\n// Split the MQTT topic into parts for downstream logic\nconst parts = msg.topic.split(\"/\");    // e.g. [\"A01R03\",\"iolink\",\"v1\",...]\nconst head  = parts[0];                  // Device identifier, e.g. \"A01R03\"\n\n// 3. Determine portTag (x0\u2013x7 or xM for gateway-level)\n//    \u2022 If topic path includes \"ports/N\", portTag = x(N-1)\n//    \u2022 Else if path includes \"devices/masterNportN\", extract similarly\nlet portTag = \"xM\";\nif (parts.includes(\"ports\")) {\n  const idx  = parts.indexOf(\"ports\");\n  const pNum = Number(parts[idx + 1]);\n  if (!isNaN(pNum) && pNum >= 1 && pNum <= 8) {\n    portTag = `x${pNum - 1}`;\n  }\n} else {\n  const devIdx = parts.indexOf(\"devices\");\n  if (devIdx !== -1) {\n    const m = /port(\\d+)/i.exec(parts[devIdx + 1]);\n    if (m) {\n      const p = Number(m[1]);\n      if (p >= 1 && p <= 8) portTag = `x${p - 1}`;\n    }\n  }\n}\n\n// 4. Section + metric detection\n//    Identify what kind of data this topic is routing:\n//    \u2013 processdata, statistics, diagnostics, configuration, events,\n//      identification, or capabilities\nlet section = \"\", metric = \"\";\nif (parts.includes(\"processdata\")) {\n  section = \"processdata\";\n  metric  = parts[parts.indexOf(\"processdata\") + 1] || \"\";\n} else if (parts.includes(\"statistics\")) {\n  section = \"statistics\";\n  metric  = parts[parts.indexOf(\"statistics\") + 1] || \"\";\n} else if (parts.includes(\"diagnostics\")) {\n  section = \"diagnostics\";\n  metric  = parts[parts.indexOf(\"diagnostics\") + 1] || \"\";\n} else if (parts.includes(\"configuration\")) {\n  section = \"configuration\";\n  // metrics not used for configuration\n} else if (parts.includes(\"events\")) {\n  section = \"events\";\n} else if (parts.includes(\"identification\")) {\n  section = \"identification\";\n} else if (parts.includes(\"capabilities\")) {\n  section = \"capabilities\";\n} else {\n  // Unknown section \u2192 discard with reason\n  msg.reason     = \"section not recognised\";\n  msg.routerTime = new Date().toISOString();\n  return [null, null, msg];\n}\n\n// 5. Construct alias map key based on section and metric\n//    \u2022 For statistics: use \"statistics_<field>\"\n//    \u2022 For diagnostics: use the field name directly\n//    \u2022 For processdata: key is \"processdata\"\n//    \u2022 Else: key = section\nconst mapKey =\n  section === \"statistics\"   ? `statistics_${metric}` :\n  section === \"diagnostics\"  ? metric                         :\n  section === \"processdata\"  ? \"processdata\"               :\n  section;\nconst aliasMap = cfg.pins?.[mapKey];\n// 5a. If mapping missing \u2192 discard\nif (!aliasMap) {\n  msg.reason     = `no mapping for '${mapKey}'`;\n  msg.routerTime = new Date().toISOString();\n  return [null, null, msg];\n}\n\n// 6. Special handling for events arrays\n//    \u2022 For \"events\": msg.payload should be an array of event objects\n//    \u2022 Send one point per event on output 0 with custom measurement, tags, and timestamp\nif (section === \"events\" && Array.isArray(msg.payload)) {\n  msg.payload.forEach(evt => {\n    node.send([{\n      payload:     evt.eventCode,\n      measurement: `${head}_${portTag}_${aliasMap.eventCode}`,\n      tags:        { severity: evt.severity },\n      timestamp:   new Date(evt.timestamp).getTime()\n    }]);\n  });\n  // End processing after events; no further messages\n  return [null, null, null];\n}\n\n// 7. Flatten nested getData & setData properties\n//    \u2022 If payload contains getData or setData objects, merge their fields into top-level payload\nif (msg.payload.getData && typeof msg.payload.getData === \"object\") {\n  Object.assign(msg.payload, msg.payload.getData);\n}\nif (msg.payload.setData && typeof msg.payload.setData === \"object\") {\n  Object.assign(msg.payload, msg.payload.setData);\n}\n\n// 8. Emit Influx points for each mapped key in aliasMap\n//    \u2022 Supports nested keys with dot notation (e.g., \"a.b.c\")\n//    \u2022 Sends one msg on output 0 per field found\nObject.entries(aliasMap).forEach(([jsonKey, alias]) => {\n  const value = jsonKey.split('.')\n    .reduce((o, k) => (o !== undefined ? o[k] : undefined), msg.payload);\n  if (value !== undefined && value !== null) {\n    node.send([{\n      payload:     value,\n      measurement: `${head}_${portTag}_${alias}`\n    }]);\n  }\n});\n\n// 9. Final step: route original raw frame to output 1 (accepted)\nreturn [null, msg, null];\n\n/**\n * How to customize:\n * - Update your `cfg.pins` object in flow context with new alias mappings.\n * - Add or modify sections by changing the `if (parts.includes(...))` blocks.\n * - Adjust event handling tag or timestamp fields under the events block.\n * - To capture raw payload on a different output, modify the final return array.\n */",
        "outputs": 3,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 480,
        "y": 1020,
        "wires": [
            [
                "bfaa229223513b0a",
                "17bdca1c684de37f"
            ],
            [
                "9b8227a1903ea259",
                "1f1c7025f2a3ce1c",
                "27d6194124762096"
            ],
            [
                "b0c120bd5e993542",
                "5fbc78e027f42a44"
            ]
        ],
        "info": "**Description:** Normalizes MQTT frames, applies alias mappings, and routes accepted/discarded payloads.\n**Inputs:** Expects structured gateway MQTT messages plus the `cfg` context loaded at startup.\n**Outputs:** `0` Influx-ready points, `1` accepted raw frames, `2` discarded frames with reasons.\n**Usage Notes:** Review inline comments for guidance when extending supported sections or troubleshooting discards."
    },
    {
        "id": "bfaa229223513b0a",
        "type": "influxdb out",
        "z": "cf2c675f8061347b",
        "g": "30ecd298364bec85",
        "influxdb": "28500336b4ee8595",
        "name": "Influx - A01",
        "measurement": "",
        "precision": "ms",
        "retentionPolicy": "",
        "database": "database",
        "precisionV18FluxV20": "ms",
        "retentionPolicyV18Flux": "",
        "org": "ADTA",
        "bucket": "A01",
        "x": 1190,
        "y": 1020,
        "wires": [],
        "info": "**Description:** Writes processed IO-Link metrics into the `A01` InfluxDB bucket.\n**Inputs:** Accepts measurement objects created by the MQTT router.\n**Outputs:** None inside the flow; forwards points to InfluxDB.\n**Usage Notes:** Ensure the bucket and precision match your InfluxDB organization before deploying."
    },
    {
        "id": "injectLoad",
        "type": "inject",
        "z": "cf2c675f8061347b",
        "g": "6bd2050295ba993d",
        "name": "Load errorCodes.json",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "",
        "crontab": "",
        "once": true,
        "onceDelay": "0.1",
        "topic": "",
        "payload": "",
        "payloadType": "str",
        "x": 200,
        "y": 160,
        "wires": [
            [
                "readFile"
            ]
        ],
        "info": "**Description:** Loads the error-code translation table into global context.\n**Inputs:** Injects once on deploy and can be manually re-triggered.\n**Outputs:** Calls *Read errorCodes.json* so error events can be enriched later.\n**Usage Notes:** Re-fire this node whenever `config/errorCodes.json` changes to refresh the in-memory lookup."
    },
    {
        "id": "readFile",
        "type": "file in",
        "z": "cf2c675f8061347b",
        "g": "6bd2050295ba993d",
        "name": "Read errorCodes.json",
        "filename": "config/errorCodes.json",
        "filenameType": "str",
        "format": "utf8",
        "chunk": false,
        "sendError": false,
        "encoding": "none",
        "allProps": false,
        "x": 440,
        "y": 160,
        "wires": [
            [
                "parseJSON"
            ]
        ],
        "info": "**Description:** Reads `config/errorCodes.json` to provide descriptive labels for gateway errors.\n**Inputs:** Triggered by the paired inject node.\n**Outputs:** Emits the file contents as a string to the JSON parser.\n**Usage Notes:** Keep the file path relative to the project so deployments on Linux remain portable."
    },
    {
        "id": "parseJSON",
        "type": "json",
        "z": "cf2c675f8061347b",
        "g": "6bd2050295ba993d",
        "name": "Parse to Object",
        "property": "payload",
        "action": "",
        "pretty": false,
        "x": 660,
        "y": 160,
        "wires": [
            [
                "storeGlobal"
            ]
        ],
        "info": "**Description:** Parses the error-code JSON into a JavaScript object.\n**Inputs:** Expects raw JSON text in `msg.payload`.\n**Outputs:** Passes the parsed lookup table to *Store in global.errorMap*.\n**Usage Notes:** Retain the default option of returning objects; the downstream function expects a dictionary."
    },
    {
        "id": "storeGlobal",
        "type": "function",
        "z": "cf2c675f8061347b",
        "g": "6bd2050295ba993d",
        "name": "Store in global.errorMap",
        "func": "// Persist the error-code map for all flows\nconst errorMap = msg.payload;\nif (typeof errorMap !== 'object' || errorMap === null) {\n    node.warn('Error map payload is not an object; nothing stored.');\n    return null;\n}\n\nif (typeof global.set === 'function') {\n    global.set('errorMap', errorMap);\n} else {\n    // Legacy fallback for very old Node-RED versions\n    context.global = context.global || {};\n    context.global.errorMap = errorMap;\n}\n\nreturn null;\n",
        "outputs": 1,
        "noerr": 0,
        "x": 880,
        "y": 160,
        "wires": [
            []
        ],
        "info": "**Description:** Persists the error-code lookup table in global context for reuse across flows.\n**Inputs:** Receives the parsed lookup object.\n**Outputs:** Returns no message.\n**Usage Notes:** Required for event enrichment; if running in a cluster ensure global context is set to a persistent storage backend."
    },
    {
        "id": "94c4b64fe48bf7a9",
        "type": "inject",
        "z": "cf2c675f8061347b",
        "g": "59c49ae82eea4453",
        "name": "trigger",
        "props": [
            {
                "p": "payload"
            }
        ],
        "repeat": "600",
        "crontab": "",
        "once": true,
        "onceDelay": "60",
        "topic": "",
        "payload": "",
        "payloadType": "str",
        "x": 160,
        "y": 420,
        "wires": [
            [
                "68bd7524f18bb41d"
            ]
        ],
        "info": "**Description:** Starts the identification poller that snapshots static gateway metadata.\n**Inputs:** Scheduler fires once after deployment and then every 60 seconds.\n**Outputs:** Sends a trigger to the secondary *generate IPs* node feeding the identification HTTP request.\n**Usage Notes:** Lengthen the repeat interval if identification rarely changes to reduce unnecessary traffic."
    },
    {
        "id": "8eaae0548f6f1ac0",
        "type": "function",
        "z": "cf2c675f8061347b",
        "g": "59c49ae82eea4453",
        "name": "build HTTP URL",
        "func": "// Prepare the identification request URL and annotate the message with gateway metadata\nconst basePath = '/iolink/v1/gateway/identification';\nconst ip = (typeof msg.payload === 'string' ? msg.payload : '').trim();\n\nif (!ip) {\n    node.warn('Missing IP in payload; identification request skipped.');\n    return null;\n}\n\nif (!/^\\d{1,3}(\\.\\d{1,3}){3}$/.test(ip)) {\n    node.warn(`Identification IP \"${ip}\" is not in IPv4 format; continuing anyway.`);\n}\n\nmsg.gateway = ip; // retained for downstream tagging\nmsg.url = `http://${ip}${basePath}`;\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 500,
        "y": 420,
        "wires": [
            [
                "b9e806b2050cdbc1"
            ]
        ],
        "info": "**Description:** Builds the identification HTTP URL and tags the originating gateway.\n**Inputs:** Expects `msg.payload` to be an IPv4 string from the identification IP generator.\n**Outputs:** Sets `msg.url` and `msg.gateway` for the GET request node.\n**Usage Notes:** Update the path inside the function when firmware revisions relocate identification data."
    },
    {
        "id": "b9e806b2050cdbc1",
        "type": "http request",
        "z": "cf2c675f8061347b",
        "g": "59c49ae82eea4453",
        "name": "GET gateway identification",
        "method": "GET",
        "ret": "obj",
        "paytoqs": "ignore",
        "url": "",
        "tls": "",
        "persist": false,
        "proxy": "",
        "insecureHTTPParser": false,
        "authType": "",
        "senderr": true,
        "headers": [],
        "x": 740,
        "y": 420,
        "wires": [
            [
                "64754fb1bd63425a"
            ]
        ],
        "info": "**Description:** Fetches the gateway identification payload over HTTP.\n**Inputs:** Requires `msg.url` from the preceding function.\n**Outputs:** Forwards successful responses to the Influx prep function.\n**Usage Notes:** Enable TLS or authentication in the node settings if gateways demand secure access."
    },
    {
        "id": "fdce59a9bc71b2ec",
        "type": "comment",
        "z": "cf2c675f8061347b",
        "g": "59c49ae82eea4453",
        "name": "GET Identification",
        "info": "**Description:** Visual divider describing the HTTP identification poller lane.\n**Inputs:** Documentation node; no runtime inputs.\n**Outputs:** None.\n**Usage Notes:** Update the text to reflect any architectural changes so the editor stays self-documenting.",
        "x": 170,
        "y": 340,
        "wires": []
    },
    {
        "id": "4561984a904805be",
        "type": "influxdb out",
        "z": "cf2c675f8061347b",
        "g": "59c49ae82eea4453",
        "influxdb": "28500336b4ee8595",
        "name": "Influx - gateway_identification",
        "measurement": "gateway_identification",
        "precision": "",
        "retentionPolicy": "",
        "database": "",
        "precisionV18FluxV20": "ns",
        "retentionPolicyV18Flux": "",
        "org": "ADTA",
        "bucket": "gateway_identification",
        "x": 1270,
        "y": 420,
        "wires": [],
        "info": "**Description:** Writes gateway identification snapshots to InfluxDB (`gateway_identification` bucket/measurement).\n**Inputs:** Receives structured payloads from *All messages to Influx*.\n**Outputs:** None within the flow.\n**Usage Notes:** Confirm measurement names align with dashboards consuming the data."
    },
    {
        "id": "64754fb1bd63425a",
        "type": "function",
        "z": "cf2c675f8061347b",
        "g": "59c49ae82eea4453",
        "name": "All messages to Influx",
        "func": "// Convert the identification payload into a single Influx point\nif (typeof msg.payload !== 'object' || msg.payload === null) {\n    node.warn('Identification payload is not an object; skipping Influx write.');\n    return null;\n}\n\nconst info = msg.payload;\nconst gateway = msg.gateway || 'unknown';\n\nconst point = {\n    measurement: 'device_info',\n    payload: {\n        macAddress:       info.macAddress,\n        serialNumber:     info.serialNumber,\n        productId:        info.productId,\n        vendorName:       info.vendorName,\n        productName:      info.productName,\n        hardwareRevision: info.hardwareRevision,\n        firmwareRevision: info.firmwareRevision,\n        gateway\n    },\n    // Use nanosecond precision to match Influx expectations\n    timestamp: Date.now() * 1e6\n};\n\nreturn [point];\n",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1000,
        "y": 420,
        "wires": [
            [
                "4561984a904805be"
            ]
        ],
        "info": "**Description:** Packages the identification response into a single Influx point with gateway metadata.\n**Inputs:** Expects the parsed identification JSON and `msg.gateway`.\n**Outputs:** Emits a single measurement object for the Influx out node.\n**Usage Notes:** Extend the payload mapping when gateways expose additional metadata that should be stored."
    },
    {
        "id": "43099c37e53f94c1",
        "type": "function",
        "z": "cf2c675f8061347b",
        "g": "6bd2050295ba993d",
        "name": "Influx data prep",
        "func": "// Enrich an individual gateway event with lookup data for InfluxDB\nconst errorMap = global.get('errorMap') || {};\nconst event = msg.payload;\n\nif (!event || typeof event !== 'object') {\n    node.warn('Event payload missing or not an object; discarding.');\n    return null;\n}\n\nif (!event.origin || !event.message) {\n    node.warn('Event payload missing origin/message metadata; discarding.');\n    return null;\n}\n\nconst masterNumber = Number(event.origin.masterNumber);\nconst portNumber = Number(event.origin.portNumber);\nconst master = Number.isFinite(masterNumber) ? masterNumber : -1;\nconst portTag = Number.isFinite(portNumber) ? `x${Math.max(portNumber - 1, 0)}` : 'xM';\n\nconst code = Number(event.message.code);\nconst hexCode = Number.isFinite(code) ? `0x${code.toString(16).toUpperCase()}` : '0x0';\n\nconst rawMode = (event.message.mode || '').toUpperCase();\nconst eventState = rawMode === 'APPEARS' ? 'event_start'\n  : rawMode === 'DISAPPEARS' ? 'event_stop'\n  : 'unknown';\n\nconst rawDeviceTimestamp = event.time ?? event.timestamp ?? event.timeStamp ?? null;\n\nmsg.topic = `impact67/master/${Number.isFinite(masterNumber) ? masterNumber : 'unknown'}/port/${portTag}`;\nmsg.timestamp = Date.now();\n\nconst description = errorMap[code] || errorMap[hexCode] || 'Unknown code';\n\nmsg.payload = {\n  severity: event.severity,\n  mode: rawMode,\n  eventState,\n  errorCode: Number.isFinite(code) ? code : null,\n  errorCodeHex: hexCode,\n  errorDescription: description,\n  master: masterNumber,\n  port: portTag,\n  isoTime: new Date(msg.timestamp).toISOString(),\n  rawDeviceTimestamp,\n  ip: msg.ip || 'unknown'\n};\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1520,
        "y": 220,
        "wires": [
            [
                "07adc65d2bd0b02c",
                "b7533422c67034ea"
            ]
        ],
        "info": "**Description:** Enriches individual gateway events with lookup data and shapes them for InfluxDB.\n**Inputs:** Receives one event at a time from the Split node plus `msg.ip`.\n**Outputs:** Sends the enriched message to Influx and to the debug serializer.\n**Usage Notes:** Review the function comments before changing context keys or topic layout\u2014downstream dashboards rely on the established schema."
    },
    {
        "id": "cab45e0aedc11ecb",
        "type": "comment",
        "z": "cf2c675f8061347b",
        "g": "6bd2050295ba993d",
        "name": "GET Events",
        "info": "**Description:** Editor note identifying the HTTP GET events swimlane.\n**Inputs:** None.\n**Outputs:** None.\n**Usage Notes:** Keep aligned with node grouping when reorganising the canvas.",
        "x": 150,
        "y": 80,
        "wires": []
    },
    {
        "id": "9d03019ea3347369",
        "type": "comment",
        "z": "cf2c675f8061347b",
        "g": "30ecd298364bec85",
        "name": "MQTT Message Routing",
        "info": "**Description:** Editor note labelling the MQTT routing swimlane.\n**Inputs:** None.\n**Outputs:** None.\n**Usage Notes:** Update wording if the routing strategy changes significantly.",
        "x": 190,
        "y": 880,
        "wires": []
    },
    {
        "id": "9b8227a1903ea259",
        "type": "function",
        "z": "cf2c675f8061347b",
        "g": "d82d2374fafffe60",
        "name": "Serialize Full Message",
        "func": "// Serialise the complete message for file-based debugging\nlet jsonText;\ntry {\n    jsonText = JSON.stringify(msg);\n} catch (err) {\n    node.warn(`Unable to serialise message: ${err.message}`);\n    jsonText = JSON.stringify({\n        error: err.message,\n        topic: msg.topic,\n        timestamp: new Date().toISOString()\n    });\n}\n\nmsg.payload = jsonText;\nreturn msg;\n",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 900,
        "y": 1320,
        "wires": [
            [
                "8fa862cf2b5615e5"
            ]
        ],
        "info": "**Description:** Serialises the full Node-RED message into a JSON string for downstream file logging.\n**Inputs:** Accepts any message object; metadata such as topic and status codes are included in the serialised output.\n**Outputs:** Returns the same message with `msg.payload` set to JSON text.\n**Usage Notes:** See inline comments for fallback behaviour when the message cannot be stringified."
    },
    {
        "id": "8fa862cf2b5615e5",
        "type": "file",
        "z": "cf2c675f8061347b",
        "g": "d82d2374fafffe60",
        "name": "E:\\NodeRed\\Logs\\MQTT_raw_frames_v.json",
        "filename": "E:\\NodeRed\\Logs\\MQTT_raw_frames_v.json",
        "filenameType": "str",
        "appendNewline": true,
        "createDir": false,
        "overwriteFile": "false",
        "encoding": "none",
        "x": 1210,
        "y": 1320,
        "wires": [
            []
        ],
        "info": "**Description:** Appends incoming payloads to `E:\\NodeRed\\Logs\\MQTT_raw_frames_v.json` for historical troubleshooting.\n**Inputs:** Expects `msg.payload` to be a JSON string produced by an upstream serializer.\n**Outputs:** None; writes directly to disk and does not forward the message.\n**Usage Notes:** Paired with a matching delete-mode File node to rotate logs safely."
    },
    {
        "id": "b0c120bd5e993542",
        "type": "function",
        "z": "cf2c675f8061347b",
        "g": "d82d2374fafffe60",
        "name": "Serialize Full Message",
        "func": "// Serialise the complete message for file-based debugging\nlet jsonText;\ntry {\n    jsonText = JSON.stringify(msg);\n} catch (err) {\n    node.warn(`Unable to serialise message: ${err.message}`);\n    jsonText = JSON.stringify({\n        error: err.message,\n        topic: msg.topic,\n        timestamp: new Date().toISOString()\n    });\n}\n\nmsg.payload = jsonText;\nreturn msg;\n",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 900,
        "y": 1400,
        "wires": [
            [
                "71be59b7c2d5a7bb"
            ]
        ],
        "info": "**Description:** Serialises the full Node-RED message into a JSON string for downstream file logging.\n**Inputs:** Accepts any message object; metadata such as topic and status codes are included in the serialised output.\n**Outputs:** Returns the same message with `msg.payload` set to JSON text.\n**Usage Notes:** See inline comments for fallback behaviour when the message cannot be stringified."
    },
    {
        "id": "71be59b7c2d5a7bb",
        "type": "file",
        "z": "cf2c675f8061347b",
        "g": "d82d2374fafffe60",
        "name": "E:\\NodeRed\\Logs\\MQTT_discard_frames_v.json",
        "filename": "E:\\NodeRed\\Logs\\MQTT_discard_frames_v.json",
        "filenameType": "str",
        "appendNewline": true,
        "createDir": false,
        "overwriteFile": "false",
        "encoding": "none",
        "x": 1220,
        "y": 1400,
        "wires": [
            []
        ],
        "info": "**Description:** Appends incoming payloads to `E:\\NodeRed\\Logs\\MQTT_discard_frames_v.json` for historical troubleshooting.\n**Inputs:** Expects `msg.payload` to be a JSON string produced by an upstream serializer.\n**Outputs:** None; writes directly to disk and does not forward the message.\n**Usage Notes:** Paired with a matching delete-mode File node to rotate logs safely."
    },
    {
        "id": "1f1c7025f2a3ce1c",
        "type": "file",
        "z": "cf2c675f8061347b",
        "g": "d82d2374fafffe60",
        "name": "E:\\NodeRed\\Logs\\MQTT_raw_frames.json",
        "filename": "E:\\NodeRed\\Logs\\MQTT_raw_frames.json",
        "filenameType": "str",
        "appendNewline": true,
        "createDir": false,
        "overwriteFile": "false",
        "encoding": "none",
        "x": 1210,
        "y": 1360,
        "wires": [
            []
        ],
        "info": "**Description:** Appends incoming payloads to `E:\\NodeRed\\Logs\\MQTT_raw_frames.json` for historical troubleshooting.\n**Inputs:** Expects `msg.payload` to be a JSON string produced by an upstream serializer.\n**Outputs:** None; writes directly to disk and does not forward the message.\n**Usage Notes:** Paired with a matching delete-mode File node to rotate logs safely."
    },
    {
        "id": "5fbc78e027f42a44",
        "type": "file",
        "z": "cf2c675f8061347b",
        "g": "d82d2374fafffe60",
        "name": "E:\\NodeRed\\Logs\\MQTT_discard_frames.json",
        "filename": "E:\\NodeRed\\Logs\\MQTT_discard_frames.json",
        "filenameType": "str",
        "appendNewline": true,
        "createDir": false,
        "overwriteFile": "false",
        "encoding": "none",
        "x": 1220,
        "y": 1440,
        "wires": [
            []
        ],
        "info": "**Description:** Appends incoming payloads to `E:\\NodeRed\\Logs\\MQTT_discard_frames.json` for historical troubleshooting.\n**Inputs:** Expects `msg.payload` to be a JSON string produced by an upstream serializer.\n**Outputs:** None; writes directly to disk and does not forward the message.\n**Usage Notes:** Paired with a matching delete-mode File node to rotate logs safely."
    },
    {
        "id": "17bdca1c684de37f",
        "type": "function",
        "z": "cf2c675f8061347b",
        "g": "d82d2374fafffe60",
        "name": "Serialize Full Message",
        "func": "// Serialise the complete message for file-based debugging\nlet jsonText;\ntry {\n    jsonText = JSON.stringify(msg);\n} catch (err) {\n    node.warn(`Unable to serialise message: ${err.message}`);\n    jsonText = JSON.stringify({\n        error: err.message,\n        topic: msg.topic,\n        timestamp: new Date().toISOString()\n    });\n}\n\nmsg.payload = jsonText;\nreturn msg;\n",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 900,
        "y": 1240,
        "wires": [
            [
                "ed545088864a6cb0"
            ]
        ],
        "info": "**Description:** Serialises the full Node-RED message into a JSON string for downstream file logging.\n**Inputs:** Accepts any message object; metadata such as topic and status codes are included in the serialised output.\n**Outputs:** Returns the same message with `msg.payload` set to JSON text.\n**Usage Notes:** See inline comments for fallback behaviour when the message cannot be stringified."
    },
    {
        "id": "ed545088864a6cb0",
        "type": "file",
        "z": "cf2c675f8061347b",
        "g": "d82d2374fafffe60",
        "name": "E:\\NodeRed\\Logs\\MQTT_Influx_v.json",
        "filename": "E:\\NodeRed\\Logs\\MQTT_Influx_v.json",
        "filenameType": "str",
        "appendNewline": true,
        "createDir": false,
        "overwriteFile": "false",
        "encoding": "none",
        "x": 1190,
        "y": 1240,
        "wires": [
            []
        ],
        "info": "**Description:** Appends incoming payloads to `E:\\NodeRed\\Logs\\MQTT_Influx_v.json` for historical troubleshooting.\n**Inputs:** Expects `msg.payload` to be a JSON string produced by an upstream serializer.\n**Outputs:** None; writes directly to disk and does not forward the message.\n**Usage Notes:** Paired with a matching delete-mode File node to rotate logs safely."
    },
    {
        "id": "27d6194124762096",
        "type": "file",
        "z": "cf2c675f8061347b",
        "g": "d82d2374fafffe60",
        "name": "E:\\NodeRed\\Logs\\MQTT_Influx.json",
        "filename": "E:\\NodeRed\\Logs\\MQTT_Influx.json",
        "filenameType": "str",
        "appendNewline": true,
        "createDir": false,
        "overwriteFile": "false",
        "encoding": "none",
        "x": 1190,
        "y": 1280,
        "wires": [
            []
        ],
        "info": "**Description:** Appends incoming payloads to `E:\\NodeRed\\Logs\\MQTT_Influx.json` for historical troubleshooting.\n**Inputs:** Expects `msg.payload` to be a JSON string produced by an upstream serializer.\n**Outputs:** None; writes directly to disk and does not forward the message.\n**Usage Notes:** Paired with a matching delete-mode File node to rotate logs safely."
    },
    {
        "id": "ea423b52b1e9b387",
        "type": "file",
        "z": "cf2c675f8061347b",
        "g": "d82d2374fafffe60",
        "name": "E:\\NodeRed\\Logs\\MQTT_raw_frames_v.json",
        "filename": "E:\\NodeRed\\Logs\\MQTT_raw_frames_v.json",
        "filenameType": "str",
        "appendNewline": true,
        "createDir": false,
        "overwriteFile": "delete",
        "encoding": "none",
        "x": 470,
        "y": 1320,
        "wires": [
            []
        ],
        "info": "**Description:** Deletes and recreates `E:\\NodeRed\\Logs\\MQTT_raw_frames_v.json` when triggered to provide a clean log file.\n**Inputs:** Any incoming message (typically from a Log Reset inject) initiates the truncate-and-recreate behaviour.\n**Outputs:** None; the node performs a filesystem operation only.\n**Usage Notes:** Use before capturing new traces to avoid mixing historical data with current sessions."
    },
    {
        "id": "37d1b98dd92fd5d8",
        "type": "file",
        "z": "cf2c675f8061347b",
        "g": "d82d2374fafffe60",
        "name": "E:\\NodeRed\\Logs\\MQTT_discard_frames_v.json",
        "filename": "E:\\NodeRed\\Logs\\MQTT_discard_frames_v.json",
        "filenameType": "str",
        "appendNewline": true,
        "createDir": false,
        "overwriteFile": "delete",
        "encoding": "none",
        "x": 480,
        "y": 1400,
        "wires": [
            []
        ],
        "info": "**Description:** Deletes and recreates `E:\\NodeRed\\Logs\\MQTT_discard_frames_v.json` when triggered to provide a clean log file.\n**Inputs:** Any incoming message (typically from a Log Reset inject) initiates the truncate-and-recreate behaviour.\n**Outputs:** None; the node performs a filesystem operation only.\n**Usage Notes:** Use before capturing new traces to avoid mixing historical data with current sessions."
    },
    {
        "id": "64b71e04aa8a1a66",
        "type": "file",
        "z": "cf2c675f8061347b",
        "g": "d82d2374fafffe60",
        "name": "E:\\NodeRed\\Logs\\MQTT_raw_frames.json",
        "filename": "E:\\NodeRed\\Logs\\MQTT_raw_frames.json",
        "filenameType": "str",
        "appendNewline": true,
        "createDir": false,
        "overwriteFile": "delete",
        "encoding": "none",
        "x": 470,
        "y": 1360,
        "wires": [
            []
        ],
        "info": "**Description:** Deletes and recreates `E:\\NodeRed\\Logs\\MQTT_raw_frames.json` when triggered to provide a clean log file.\n**Inputs:** Any incoming message (typically from a Log Reset inject) initiates the truncate-and-recreate behaviour.\n**Outputs:** None; the node performs a filesystem operation only.\n**Usage Notes:** Use before capturing new traces to avoid mixing historical data with current sessions."
    },
    {
        "id": "22361c21b043030f",
        "type": "file",
        "z": "cf2c675f8061347b",
        "g": "d82d2374fafffe60",
        "name": "E:\\NodeRed\\Logs\\MQTT_discard_frames.json",
        "filename": "E:\\NodeRed\\Logs\\MQTT_discard_frames.json",
        "filenameType": "str",
        "appendNewline": true,
        "createDir": false,
        "overwriteFile": "delete",
        "encoding": "none",
        "x": 480,
        "y": 1440,
        "wires": [
            []
        ],
        "info": "**Description:** Deletes and recreates `E:\\NodeRed\\Logs\\MQTT_discard_frames.json` when triggered to provide a clean log file.\n**Inputs:** Any incoming message (typically from a Log Reset inject) initiates the truncate-and-recreate behaviour.\n**Outputs:** None; the node performs a filesystem operation only.\n**Usage Notes:** Use before capturing new traces to avoid mixing historical data with current sessions."
    },
    {
        "id": "f5ac08b67bcbd3f4",
        "type": "file",
        "z": "cf2c675f8061347b",
        "g": "d82d2374fafffe60",
        "name": "E:\\NodeRed\\Logs\\MQTT_Influx_v.json",
        "filename": "E:\\NodeRed\\Logs\\MQTT_Influx_v.json",
        "filenameType": "str",
        "appendNewline": true,
        "createDir": false,
        "overwriteFile": "delete",
        "encoding": "none",
        "x": 450,
        "y": 1240,
        "wires": [
            []
        ],
        "info": "**Description:** Deletes and recreates `E:\\NodeRed\\Logs\\MQTT_Influx_v.json` when triggered to provide a clean log file.\n**Inputs:** Any incoming message (typically from a Log Reset inject) initiates the truncate-and-recreate behaviour.\n**Outputs:** None; the node performs a filesystem operation only.\n**Usage Notes:** Use before capturing new traces to avoid mixing historical data with current sessions."
    },
    {
        "id": "818bedb30d9efcc5",
        "type": "file",
        "z": "cf2c675f8061347b",
        "g": "d82d2374fafffe60",
        "name": "E:\\NodeRed\\Logs\\MQTT_Influx.json",
        "filename": "E:\\NodeRed\\Logs\\MQTT_Influx.json",
        "filenameType": "str",
        "appendNewline": true,
        "createDir": false,
        "overwriteFile": "delete",
        "encoding": "none",
        "x": 450,
        "y": 1280,
        "wires": [
            []
        ],
        "info": "**Description:** Deletes and recreates `E:\\NodeRed\\Logs\\MQTT_Influx.json` when triggered to provide a clean log file.\n**Inputs:** Any incoming message (typically from a Log Reset inject) initiates the truncate-and-recreate behaviour.\n**Outputs:** None; the node performs a filesystem operation only.\n**Usage Notes:** Use before capturing new traces to avoid mixing historical data with current sessions."
    },
    {
        "id": "2cf6872e1b3ad487",
        "type": "inject",
        "z": "cf2c675f8061347b",
        "g": "d82d2374fafffe60",
        "name": "Log Reset",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "172800",
        "crontab": "",
        "once": true,
        "onceDelay": "0.1",
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 170,
        "y": 1260,
        "wires": [
            [
                "70a12dada24e2da5",
                "78b2a95148c008a2",
                "f5ac08b67bcbd3f4",
                "818bedb30d9efcc5",
                "ea423b52b1e9b387",
                "64b71e04aa8a1a66",
                "37d1b98dd92fd5d8",
                "22361c21b043030f",
                "ef8a0a0990524f77",
                "e223c50d5c721039"
            ]
        ],
        "info": "**Description:** Periodically clears verbose MQTT log files to keep disk usage predictable.\n**Inputs:** Fires once at startup and every 172800 seconds (48 hours).\n**Outputs:** Sends a timestamp payload to each housekeeping File node configured to delete-and-recreate logs.\n**Usage Notes:** Adjust the repeat value to match retention policies. Manual trigger purges logs immediately."
    },
    {
        "id": "e4624ef9b4a1d94b",
        "type": "comment",
        "z": "cf2c675f8061347b",
        "g": "d82d2374fafffe60",
        "name": "MQTT Logging",
        "info": "**Description:** Canvas annotation explaining the MQTT logging and reset utilities.\n**Inputs:** None.\n**Outputs:** None.\n**Usage Notes:** Keep the note updated as logging targets evolve.",
        "x": 160,
        "y": 1160,
        "wires": []
    },
    {
        "id": "4adb3d0d2a6e026e",
        "type": "function",
        "z": "cf2c675f8061347b",
        "g": "d82d2374fafffe60",
        "name": "Serialize Full Message",
        "func": "// Serialise the complete message for file-based debugging\nlet jsonText;\ntry {\n    jsonText = JSON.stringify(msg);\n} catch (err) {\n    node.warn(`Unable to serialise message: ${err.message}`);\n    jsonText = JSON.stringify({\n        error: err.message,\n        topic: msg.topic,\n        timestamp: new Date().toISOString()\n    });\n}\n\nmsg.payload = jsonText;\nreturn msg;\n",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 900,
        "y": 1160,
        "wires": [
            [
                "00df87db84b78811"
            ]
        ],
        "info": "**Description:** Serialises the full Node-RED message into a JSON string for downstream file logging.\n**Inputs:** Accepts any message object; metadata such as topic and status codes are included in the serialised output.\n**Outputs:** Returns the same message with `msg.payload` set to JSON text.\n**Usage Notes:** See inline comments for fallback behaviour when the message cannot be stringified."
    },
    {
        "id": "00df87db84b78811",
        "type": "file",
        "z": "cf2c675f8061347b",
        "g": "d82d2374fafffe60",
        "name": "E:\\NodeRed\\Logs\\MQTT_raw_input_v.json",
        "filename": "E:\\NodeRed\\Logs\\MQTT_raw_input_v.json",
        "filenameType": "str",
        "appendNewline": true,
        "createDir": false,
        "overwriteFile": "false",
        "encoding": "none",
        "x": 1210,
        "y": 1160,
        "wires": [
            []
        ],
        "info": "**Description:** Appends incoming payloads to `E:\\NodeRed\\Logs\\MQTT_raw_input_v.json` for historical troubleshooting.\n**Inputs:** Expects `msg.payload` to be a JSON string produced by an upstream serializer.\n**Outputs:** None; writes directly to disk and does not forward the message.\n**Usage Notes:** Paired with a matching delete-mode File node to rotate logs safely."
    },
    {
        "id": "79356ea0aadc9a91",
        "type": "file",
        "z": "cf2c675f8061347b",
        "g": "d82d2374fafffe60",
        "name": "E:\\NodeRed\\Logs\\MQTT_raw_input.json",
        "filename": "E:\\NodeRed\\Logs\\MQTT_raw_input.json",
        "filenameType": "str",
        "appendNewline": true,
        "createDir": false,
        "overwriteFile": "false",
        "encoding": "none",
        "x": 1200,
        "y": 1200,
        "wires": [
            []
        ],
        "info": "**Description:** Appends incoming payloads to `E:\\NodeRed\\Logs\\MQTT_raw_input.json` for historical troubleshooting.\n**Inputs:** Expects `msg.payload` to be a JSON string produced by an upstream serializer.\n**Outputs:** None; writes directly to disk and does not forward the message.\n**Usage Notes:** Paired with a matching delete-mode File node to rotate logs safely."
    },
    {
        "id": "70a12dada24e2da5",
        "type": "file",
        "z": "cf2c675f8061347b",
        "g": "d82d2374fafffe60",
        "name": "E:\\NodeRed\\Logs\\MQTT_raw_input_v.json",
        "filename": "E:\\NodeRed\\Logs\\MQTT_raw_input_v.json",
        "filenameType": "str",
        "appendNewline": true,
        "createDir": false,
        "overwriteFile": "delete",
        "encoding": "none",
        "x": 470,
        "y": 1160,
        "wires": [
            []
        ],
        "info": "**Description:** Deletes and recreates `E:\\NodeRed\\Logs\\MQTT_raw_input_v.json` when triggered to provide a clean log file.\n**Inputs:** Any incoming message (typically from a Log Reset inject) initiates the truncate-and-recreate behaviour.\n**Outputs:** None; the node performs a filesystem operation only.\n**Usage Notes:** Use before capturing new traces to avoid mixing historical data with current sessions."
    },
    {
        "id": "78b2a95148c008a2",
        "type": "file",
        "z": "cf2c675f8061347b",
        "g": "d82d2374fafffe60",
        "name": "E:\\NodeRed\\Logs\\MQTT_raw_input.json",
        "filename": "E:\\NodeRed\\Logs\\MQTT_raw_input.json",
        "filenameType": "str",
        "appendNewline": true,
        "createDir": false,
        "overwriteFile": "delete",
        "encoding": "none",
        "x": 460,
        "y": 1200,
        "wires": [
            []
        ],
        "info": "**Description:** Deletes and recreates `E:\\NodeRed\\Logs\\MQTT_raw_input.json` when triggered to provide a clean log file.\n**Inputs:** Any incoming message (typically from a Log Reset inject) initiates the truncate-and-recreate behaviour.\n**Outputs:** None; the node performs a filesystem operation only.\n**Usage Notes:** Use before capturing new traces to avoid mixing historical data with current sessions."
    },
    {
        "id": "68bd7524f18bb41d",
        "type": "function",
        "z": "cf2c675f8061347b",
        "g": "59c49ae82eea4453",
        "name": "generate IPs",
        "func": "/**\n * Build a list of gateway IP addresses for downstream polling.\n * - Supports individual hosts via `host`\n * - Supports numeric ranges via `start` and `end`\n * - Emits one message per IP with both `msg.payload` and `msg.ip` populated\n */\nconst ranges = [\n    { base: '192.168.1', start: 111, end: 130 }\n];\n\n// Guard against a missing configuration so the runtime stays quiet\nif (!Array.isArray(ranges) || ranges.length === 0) {\n    node.warn('No IP ranges configured; skipping poll trigger.');\n    return [[]];\n}\n\nconst ips = []; // collected Node-RED messages\n\nfor (const range of ranges) {\n    // Handle explicit host definitions (single addresses)\n    if (range.host !== undefined) {\n        const ip = `${range.base}.${range.host}`;\n        ips.push({ payload: ip, ip });\n        continue;\n    }\n\n    // Handle numeric ranges; reject malformed values gracefully\n    if (range.start !== undefined && range.end !== undefined) {\n        const start = Number(range.start);\n        const end = Number(range.end);\n        if (Number.isFinite(start) && Number.isFinite(end) && end >= start) {\n            for (let i = start; i <= end; i++) {\n                const ip = `${range.base}.${i}`;\n                ips.push({ payload: ip, ip });\n            }\n        } else {\n            node.warn(`Skipping invalid range definition: ${JSON.stringify(range)}`);\n        }\n        continue;\n    }\n\n    // Anything without host/start/end is ignored but surfaced for debugging\n    node.warn(`Skipping entry without host or range: ${JSON.stringify(range)}`);\n}\n\nif (ips.length === 0) {\n    node.warn('Configured ranges produced no addresses; verify host boundaries.');\n}\n\nreturn [ips];\n",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 310,
        "y": 420,
        "wires": [
            [
                "8eaae0548f6f1ac0"
            ]
        ],
        "info": "**Description:** Generates the IP list used by the identification poller.\n**Inputs:** Receives a trigger from the scheduled inject node.\n**Outputs:** Emits one message per configured IP so the identification HTTP flow can iterate.\n**Usage Notes:** Keep the ranges array in sync with the primary poller to avoid uneven coverage."
    },
    {
        "id": "820eca120de9c8dc",
        "type": "function",
        "z": "cf2c675f8061347b",
        "g": "b985c3ba5e5519d9",
        "name": "Serialize Full Message",
        "func": "// Serialise the complete message for file-based debugging\nlet jsonText;\ntry {\n    jsonText = JSON.stringify(msg);\n} catch (err) {\n    node.warn(`Unable to serialise message: ${err.message}`);\n    jsonText = JSON.stringify({\n        error: err.message,\n        topic: msg.topic,\n        timestamp: new Date().toISOString()\n    });\n}\n\nmsg.payload = jsonText;\nreturn msg;\n",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 760,
        "y": 600,
        "wires": [
            [
                "d6ed388d600d8ec0"
            ]
        ],
        "info": "**Description:** Serialises the full Node-RED message into a JSON string for downstream file logging.\n**Inputs:** Accepts any message object; metadata such as topic and status codes are included in the serialised output.\n**Outputs:** Returns the same message with `msg.payload` set to JSON text.\n**Usage Notes:** See inline comments for fallback behaviour when the message cannot be stringified."
    },
    {
        "id": "b580f3c166ef8dda",
        "type": "inject",
        "z": "cf2c675f8061347b",
        "g": "b985c3ba5e5519d9",
        "name": "Log Reset",
        "props": [
            {
                "p": "payload"
            },
            {
                "p": "topic",
                "vt": "str"
            }
        ],
        "repeat": "172800",
        "crontab": "",
        "once": true,
        "onceDelay": 0.1,
        "topic": "",
        "payload": "",
        "payloadType": "date",
        "x": 170,
        "y": 680,
        "wires": [
            [
                "020cd237371f7f2d",
                "88d0db573e750331",
                "e34aa1f071f6d44f",
                "e2930e5ebe425c46",
                "d320d8d3aff09585"
            ]
        ],
        "info": "**Description:** Resets the staged HTTP debug logs captured by the GET pipelines.\n**Inputs:** Fires on deployment and then every 48 hours.\n**Outputs:** Pushes a payload into the GET logging File nodes that are set to delete existing captures.\n**Usage Notes:** Trigger manually before a troubleshooting session to start with a clean set of request/response traces."
    },
    {
        "id": "020cd237371f7f2d",
        "type": "file",
        "z": "cf2c675f8061347b",
        "g": "b985c3ba5e5519d9",
        "name": "E:\\NodeRed\\Logs\\01_GET_request.json",
        "filename": "E:\\NodeRed\\Logs\\01_GET_request.json",
        "filenameType": "str",
        "appendNewline": true,
        "createDir": false,
        "overwriteFile": "delete",
        "encoding": "none",
        "x": 440,
        "y": 600,
        "wires": [
            []
        ],
        "info": "**Description:** Deletes and recreates `E:\\NodeRed\\Logs\\01_GET_request.json` when triggered to provide a clean log file.\n**Inputs:** Any incoming message (typically from a Log Reset inject) initiates the truncate-and-recreate behaviour.\n**Outputs:** None; the node performs a filesystem operation only.\n**Usage Notes:** Use before capturing new traces to avoid mixing historical data with current sessions."
    },
    {
        "id": "88d0db573e750331",
        "type": "file",
        "z": "cf2c675f8061347b",
        "g": "b985c3ba5e5519d9",
        "name": "E:\\NodeRed\\Logs\\02_GET_reply.json",
        "filename": "E:\\NodeRed\\Logs\\02_GET_reply.json",
        "filenameType": "str",
        "appendNewline": true,
        "createDir": false,
        "overwriteFile": "delete",
        "encoding": "none",
        "x": 430,
        "y": 640,
        "wires": [
            []
        ],
        "info": "**Description:** Deletes and recreates `E:\\NodeRed\\Logs\\02_GET_reply.json` when triggered to provide a clean log file.\n**Inputs:** Any incoming message (typically from a Log Reset inject) initiates the truncate-and-recreate behaviour.\n**Outputs:** None; the node performs a filesystem operation only.\n**Usage Notes:** Use before capturing new traces to avoid mixing historical data with current sessions."
    },
    {
        "id": "d6ed388d600d8ec0",
        "type": "file",
        "z": "cf2c675f8061347b",
        "g": "b985c3ba5e5519d9",
        "name": "E:\\NodeRed\\Logs\\01_GET_request.json",
        "filename": "E:\\NodeRed\\Logs\\01_GET_request.json",
        "filenameType": "str",
        "appendNewline": true,
        "createDir": false,
        "overwriteFile": "false",
        "encoding": "none",
        "x": 1060,
        "y": 600,
        "wires": [
            []
        ],
        "info": "**Description:** Appends incoming payloads to `E:\\NodeRed\\Logs\\01_GET_request.json` for historical troubleshooting.\n**Inputs:** Expects `msg.payload` to be a JSON string produced by an upstream serializer.\n**Outputs:** None; writes directly to disk and does not forward the message.\n**Usage Notes:** Paired with a matching delete-mode File node to rotate logs safely."
    },
    {
        "id": "5228d7f553f62aef",
        "type": "function",
        "z": "cf2c675f8061347b",
        "g": "b985c3ba5e5519d9",
        "name": "Serialize Full Message",
        "func": "// Serialise the complete message for file-based debugging\nlet jsonText;\ntry {\n    jsonText = JSON.stringify(msg);\n} catch (err) {\n    node.warn(`Unable to serialise message: ${err.message}`);\n    jsonText = JSON.stringify({\n        error: err.message,\n        topic: msg.topic,\n        timestamp: new Date().toISOString()\n    });\n}\n\nmsg.payload = jsonText;\nreturn msg;\n",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 760,
        "y": 640,
        "wires": [
            [
                "b773ec8167ad6eac"
            ]
        ],
        "info": "**Description:** Serialises the full Node-RED message into a JSON string for downstream file logging.\n**Inputs:** Accepts any message object; metadata such as topic and status codes are included in the serialised output.\n**Outputs:** Returns the same message with `msg.payload` set to JSON text.\n**Usage Notes:** See inline comments for fallback behaviour when the message cannot be stringified."
    },
    {
        "id": "b773ec8167ad6eac",
        "type": "file",
        "z": "cf2c675f8061347b",
        "g": "b985c3ba5e5519d9",
        "name": "E:\\NodeRed\\Logs\\02_GET_reply.json",
        "filename": "E:\\NodeRed\\Logs\\02_GET_reply.json",
        "filenameType": "str",
        "appendNewline": true,
        "createDir": false,
        "overwriteFile": "false",
        "encoding": "none",
        "x": 1050,
        "y": 640,
        "wires": [
            []
        ],
        "info": "**Description:** Appends incoming payloads to `E:\\NodeRed\\Logs\\02_GET_reply.json` for historical troubleshooting.\n**Inputs:** Expects `msg.payload` to be a JSON string produced by an upstream serializer.\n**Outputs:** None; writes directly to disk and does not forward the message.\n**Usage Notes:** Paired with a matching delete-mode File node to rotate logs safely."
    },
    {
        "id": "eebe93151283d1c7",
        "type": "function",
        "z": "cf2c675f8061347b",
        "g": "b985c3ba5e5519d9",
        "name": "Serialize Full Message",
        "func": "// Serialise the complete message for file-based debugging\nlet jsonText;\ntry {\n    jsonText = JSON.stringify(msg);\n} catch (err) {\n    node.warn(`Unable to serialise message: ${err.message}`);\n    jsonText = JSON.stringify({\n        error: err.message,\n        topic: msg.topic,\n        timestamp: new Date().toISOString()\n    });\n}\n\nmsg.payload = jsonText;\nreturn msg;\n",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 760,
        "y": 680,
        "wires": [
            [
                "7010792667254c11"
            ]
        ],
        "info": "**Description:** Serialises the full Node-RED message into a JSON string for downstream file logging.\n**Inputs:** Accepts any message object; metadata such as topic and status codes are included in the serialised output.\n**Outputs:** Returns the same message with `msg.payload` set to JSON text.\n**Usage Notes:** See inline comments for fallback behaviour when the message cannot be stringified."
    },
    {
        "id": "7010792667254c11",
        "type": "file",
        "z": "cf2c675f8061347b",
        "g": "b985c3ba5e5519d9",
        "name": "E:\\NodeRed\\Logs\\03_GET_tag.json",
        "filename": "E:\\NodeRed\\Logs\\03_GET_tag.json",
        "filenameType": "str",
        "appendNewline": true,
        "createDir": false,
        "overwriteFile": "false",
        "encoding": "none",
        "x": 1040,
        "y": 680,
        "wires": [
            []
        ],
        "info": "**Description:** Appends incoming payloads to `E:\\NodeRed\\Logs\\03_GET_tag.json` for historical troubleshooting.\n**Inputs:** Expects `msg.payload` to be a JSON string produced by an upstream serializer.\n**Outputs:** None; writes directly to disk and does not forward the message.\n**Usage Notes:** Paired with a matching delete-mode File node to rotate logs safely."
    },
    {
        "id": "98cb5aedb10e2562",
        "type": "function",
        "z": "cf2c675f8061347b",
        "g": "b985c3ba5e5519d9",
        "name": "Serialize Full Message",
        "func": "// Serialise the complete message for file-based debugging\nlet jsonText;\ntry {\n    jsonText = JSON.stringify(msg);\n} catch (err) {\n    node.warn(`Unable to serialise message: ${err.message}`);\n    jsonText = JSON.stringify({\n        error: err.message,\n        topic: msg.topic,\n        timestamp: new Date().toISOString()\n    });\n}\n\nmsg.payload = jsonText;\nreturn msg;\n",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 760,
        "y": 720,
        "wires": [
            [
                "687557aee3e668df"
            ]
        ],
        "info": "**Description:** Serialises the full Node-RED message into a JSON string for downstream file logging.\n**Inputs:** Accepts any message object; metadata such as topic and status codes are included in the serialised output.\n**Outputs:** Returns the same message with `msg.payload` set to JSON text.\n**Usage Notes:** See inline comments for fallback behaviour when the message cannot be stringified."
    },
    {
        "id": "687557aee3e668df",
        "type": "file",
        "z": "cf2c675f8061347b",
        "g": "b985c3ba5e5519d9",
        "name": "E:\\NodeRed\\Logs\\04_GET_split.json",
        "filename": "E:\\NodeRed\\Logs\\04_GET_split.json",
        "filenameType": "str",
        "appendNewline": true,
        "createDir": false,
        "overwriteFile": "false",
        "encoding": "none",
        "x": 1050,
        "y": 720,
        "wires": [
            []
        ],
        "info": "**Description:** Appends incoming payloads to `E:\\NodeRed\\Logs\\04_GET_split.json` for historical troubleshooting.\n**Inputs:** Expects `msg.payload` to be a JSON string produced by an upstream serializer.\n**Outputs:** None; writes directly to disk and does not forward the message.\n**Usage Notes:** Paired with a matching delete-mode File node to rotate logs safely."
    },
    {
        "id": "b7533422c67034ea",
        "type": "function",
        "z": "cf2c675f8061347b",
        "g": "b985c3ba5e5519d9",
        "name": "Serialize Full Message",
        "func": "// Serialise the complete message for file-based debugging\nlet jsonText;\ntry {\n    jsonText = JSON.stringify(msg);\n} catch (err) {\n    node.warn(`Unable to serialise message: ${err.message}`);\n    jsonText = JSON.stringify({\n        error: err.message,\n        topic: msg.topic,\n        timestamp: new Date().toISOString()\n    });\n}\n\nmsg.payload = jsonText;\nreturn msg;\n",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 760,
        "y": 760,
        "wires": [
            [
                "152b94b2cb4c6c3a"
            ]
        ],
        "info": "**Description:** Serialises the full Node-RED message into a JSON string for downstream file logging.\n**Inputs:** Accepts any message object; metadata such as topic and status codes are included in the serialised output.\n**Outputs:** Returns the same message with `msg.payload` set to JSON text.\n**Usage Notes:** See inline comments for fallback behaviour when the message cannot be stringified."
    },
    {
        "id": "152b94b2cb4c6c3a",
        "type": "file",
        "z": "cf2c675f8061347b",
        "g": "b985c3ba5e5519d9",
        "name": "E:\\NodeRed\\Logs\\05_GET_influx.json",
        "filename": "E:\\NodeRed\\Logs\\05_GET_influx.json",
        "filenameType": "str",
        "appendNewline": true,
        "createDir": false,
        "overwriteFile": "false",
        "encoding": "none",
        "x": 1050,
        "y": 760,
        "wires": [
            []
        ],
        "info": "**Description:** Appends incoming payloads to `E:\\NodeRed\\Logs\\05_GET_influx.json` for historical troubleshooting.\n**Inputs:** Expects `msg.payload` to be a JSON string produced by an upstream serializer.\n**Outputs:** None; writes directly to disk and does not forward the message.\n**Usage Notes:** Paired with a matching delete-mode File node to rotate logs safely."
    },
    {
        "id": "e34aa1f071f6d44f",
        "type": "file",
        "z": "cf2c675f8061347b",
        "g": "b985c3ba5e5519d9",
        "name": "E:\\NodeRed\\Logs\\03_GET_tag.json",
        "filename": "E:\\NodeRed\\Logs\\03_GET_tag.json",
        "filenameType": "str",
        "appendNewline": true,
        "createDir": false,
        "overwriteFile": "delete",
        "encoding": "none",
        "x": 420,
        "y": 680,
        "wires": [
            []
        ],
        "info": "**Description:** Deletes and recreates `E:\\NodeRed\\Logs\\03_GET_tag.json` when triggered to provide a clean log file.\n**Inputs:** Any incoming message (typically from a Log Reset inject) initiates the truncate-and-recreate behaviour.\n**Outputs:** None; the node performs a filesystem operation only.\n**Usage Notes:** Use before capturing new traces to avoid mixing historical data with current sessions."
    },
    {
        "id": "e2930e5ebe425c46",
        "type": "file",
        "z": "cf2c675f8061347b",
        "g": "b985c3ba5e5519d9",
        "name": "E:\\NodeRed\\Logs\\04_GET_split.json",
        "filename": "E:\\NodeRed\\Logs\\04_GET_split.json",
        "filenameType": "str",
        "appendNewline": true,
        "createDir": false,
        "overwriteFile": "delete",
        "encoding": "none",
        "x": 430,
        "y": 720,
        "wires": [
            []
        ],
        "info": "**Description:** Deletes and recreates `E:\\NodeRed\\Logs\\04_GET_split.json` when triggered to provide a clean log file.\n**Inputs:** Any incoming message (typically from a Log Reset inject) initiates the truncate-and-recreate behaviour.\n**Outputs:** None; the node performs a filesystem operation only.\n**Usage Notes:** Use before capturing new traces to avoid mixing historical data with current sessions."
    },
    {
        "id": "d320d8d3aff09585",
        "type": "file",
        "z": "cf2c675f8061347b",
        "g": "b985c3ba5e5519d9",
        "name": "E:\\NodeRed\\Logs\\05_GET_influx.json",
        "filename": "E:\\NodeRed\\Logs\\05_GET_influx.json",
        "filenameType": "str",
        "appendNewline": true,
        "createDir": false,
        "overwriteFile": "delete",
        "encoding": "none",
        "x": 430,
        "y": 760,
        "wires": [
            []
        ],
        "info": "**Description:** Deletes and recreates `E:\\NodeRed\\Logs\\05_GET_influx.json` when triggered to provide a clean log file.\n**Inputs:** Any incoming message (typically from a Log Reset inject) initiates the truncate-and-recreate behaviour.\n**Outputs:** None; the node performs a filesystem operation only.\n**Usage Notes:** Use before capturing new traces to avoid mixing historical data with current sessions."
    },
    {
        "id": "06c17a95883f1b43",
        "type": "comment",
        "z": "cf2c675f8061347b",
        "g": "b985c3ba5e5519d9",
        "name": "GET Logging",
        "info": "**Description:** Annotation describing the HTTP GET logging utilities.\n**Inputs:** None.\n**Outputs:** None.\n**Usage Notes:** Keep wording aligned with the log rotation nodes it references.",
        "x": 150,
        "y": 540,
        "wires": []
    },
    {
        "id": "3443c80672c5e636",
        "type": "mqtt in",
        "z": "cf2c675f8061347b",
        "g": "d82d2374fafffe60",
        "name": "#",
        "topic": "#",
        "qos": "1",
        "datatype": "auto-detect",
        "broker": "mqtt-broker-local",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 0,
        "x": 150,
        "y": 1620,
        "wires": [
            [
                "2a62ca5551eb6109"
            ]
        ],
        "info": "**Description:** MQTT subscription that captures every topic on the broker for diagnostic logging.\n**Inputs:** No flow input; subscribes to topic `#`.\n**Outputs:** Sends frames to the serialiser feeding the catch-all log files.\n**Usage Notes:** Disable or narrow the topic filter during production to reduce noise and disk usage."
    },
    {
        "id": "2bd8aa8546924e19",
        "type": "mqtt in",
        "z": "cf2c675f8061347b",
        "g": "d82d2374fafffe60",
        "name": "$SYS/#",
        "topic": "$SYS/#",
        "qos": "1",
        "datatype": "auto-detect",
        "broker": "mqtt-broker-local",
        "nl": false,
        "rap": true,
        "rh": 0,
        "inputs": 0,
        "x": 150,
        "y": 1680,
        "wires": [
            [
                "13fd02c9973d8e8b"
            ]
        ],
        "info": "**Description:** MQTT subscription capturing broker control topics for auditing.\n**Inputs:** No flow input; listens on `$SYS/#`.\n**Outputs:** Routes frames to the serializer for SYS topic logging.\n**Usage Notes:** Useful when diagnosing broker health; consider disabling if logs grow too quickly."
    },
    {
        "id": "2a62ca5551eb6109",
        "type": "function",
        "z": "cf2c675f8061347b",
        "g": "d82d2374fafffe60",
        "name": "Serialize Full Message",
        "func": "// Serialise the complete message for file-based debugging\nlet jsonText;\ntry {\n    jsonText = JSON.stringify(msg);\n} catch (err) {\n    node.warn(`Unable to serialise message: ${err.message}`);\n    jsonText = JSON.stringify({\n        error: err.message,\n        topic: msg.topic,\n        timestamp: new Date().toISOString()\n    });\n}\n\nmsg.payload = jsonText;\nreturn msg;\n",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 900,
        "y": 1620,
        "wires": [
            [
                "713a0f9a472d65ca"
            ]
        ],
        "info": "**Description:** Serialises the full Node-RED message into a JSON string for downstream file logging.\n**Inputs:** Accepts any message object; metadata such as topic and status codes are included in the serialised output.\n**Outputs:** Returns the same message with `msg.payload` set to JSON text.\n**Usage Notes:** See inline comments for fallback behaviour when the message cannot be stringified."
    },
    {
        "id": "713a0f9a472d65ca",
        "type": "file",
        "z": "cf2c675f8061347b",
        "g": "d82d2374fafffe60",
        "name": "E:\\NodeRed\\Logs\\#_v.json",
        "filename": "E:\\NodeRed\\Logs\\#_v.json",
        "filenameType": "str",
        "appendNewline": true,
        "createDir": false,
        "overwriteFile": "false",
        "encoding": "none",
        "x": 1160,
        "y": 1620,
        "wires": [
            []
        ],
        "info": "**Description:** Appends incoming payloads to `E:\\NodeRed\\Logs\\#_v.json` for historical troubleshooting.\n**Inputs:** Expects `msg.payload` to be a JSON string produced by an upstream serializer.\n**Outputs:** None; writes directly to disk and does not forward the message.\n**Usage Notes:** Paired with a matching delete-mode File node to rotate logs safely."
    },
    {
        "id": "ef8a0a0990524f77",
        "type": "file",
        "z": "cf2c675f8061347b",
        "g": "d82d2374fafffe60",
        "name": "E:\\NodeRed\\Logs\\#_v.json",
        "filename": "E:\\NodeRed\\Logs\\#_v.json",
        "filenameType": "str",
        "appendNewline": true,
        "createDir": false,
        "overwriteFile": "delete",
        "encoding": "none",
        "x": 420,
        "y": 1480,
        "wires": [
            []
        ],
        "info": "**Description:** Deletes and recreates `E:\\NodeRed\\Logs\\#_v.json` when triggered to provide a clean log file.\n**Inputs:** Any incoming message (typically from a Log Reset inject) initiates the truncate-and-recreate behaviour.\n**Outputs:** None; the node performs a filesystem operation only.\n**Usage Notes:** Use before capturing new traces to avoid mixing historical data with current sessions."
    },
    {
        "id": "13fd02c9973d8e8b",
        "type": "function",
        "z": "cf2c675f8061347b",
        "g": "d82d2374fafffe60",
        "name": "Serialize Full Message",
        "func": "// Serialise the complete message for file-based debugging\nlet jsonText;\ntry {\n    jsonText = JSON.stringify(msg);\n} catch (err) {\n    node.warn(`Unable to serialise message: ${err.message}`);\n    jsonText = JSON.stringify({\n        error: err.message,\n        topic: msg.topic,\n        timestamp: new Date().toISOString()\n    });\n}\n\nmsg.payload = jsonText;\nreturn msg;\n",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 900,
        "y": 1680,
        "wires": [
            [
                "2766c1795827424a"
            ]
        ],
        "info": "**Description:** Serialises the full Node-RED message into a JSON string for downstream file logging.\n**Inputs:** Accepts any message object; metadata such as topic and status codes are included in the serialised output.\n**Outputs:** Returns the same message with `msg.payload` set to JSON text.\n**Usage Notes:** See inline comments for fallback behaviour when the message cannot be stringified."
    },
    {
        "id": "2766c1795827424a",
        "type": "file",
        "z": "cf2c675f8061347b",
        "g": "d82d2374fafffe60",
        "name": "E:\\NodeRed\\Logs\\$SYS_v.json",
        "filename": "E:\\NodeRed\\Logs\\$SYS_v.json",
        "filenameType": "str",
        "appendNewline": true,
        "createDir": false,
        "overwriteFile": "false",
        "encoding": "none",
        "x": 1170,
        "y": 1680,
        "wires": [
            []
        ],
        "info": "**Description:** Appends incoming payloads to `E:\\NodeRed\\Logs\\$SYS_v.json` for historical troubleshooting.\n**Inputs:** Expects `msg.payload` to be a JSON string produced by an upstream serializer.\n**Outputs:** None; writes directly to disk and does not forward the message.\n**Usage Notes:** Paired with a matching delete-mode File node to rotate logs safely."
    },
    {
        "id": "e223c50d5c721039",
        "type": "file",
        "z": "cf2c675f8061347b",
        "g": "d82d2374fafffe60",
        "name": "E:\\NodeRed\\Logs\\$SYS_v.json",
        "filename": "E:\\NodeRed\\Logs\\$SYS_v.json",
        "filenameType": "str",
        "appendNewline": true,
        "createDir": false,
        "overwriteFile": "delete",
        "encoding": "none",
        "x": 430,
        "y": 1520,
        "wires": [
            []
        ],
        "info": "**Description:** Deletes and recreates `E:\\NodeRed\\Logs\\$SYS_v.json` when triggered to provide a clean log file.\n**Inputs:** Any incoming message (typically from a Log Reset inject) initiates the truncate-and-recreate behaviour.\n**Outputs:** None; the node performs a filesystem operation only.\n**Usage Notes:** Use before capturing new traces to avoid mixing historical data with current sessions."
    },
    {
        "id": "23be7c7ce3851001",
        "type": "function",
        "z": "cf2c675f8061347b",
        "g": "6bd2050295ba993d",
        "name": "Influx data prep",
        "func": "// Enrich an individual gateway event with lookup data for InfluxDB\nconst errorMap = global.get('errorMap') || {};\nconst event = msg.payload;\n\nif (!event || typeof event !== 'object') {\n    node.warn('Event payload missing or not an object; discarding.');\n    return null;\n}\n\nif (!event.origin || !event.message) {\n    node.warn('Event payload missing origin/message metadata; discarding.');\n    return null;\n}\n\nconst masterNumber = Number(event.origin.masterNumber);\nconst portNumber = Number(event.origin.portNumber);\nconst master = Number.isFinite(masterNumber) ? masterNumber : -1;\nconst portTag = Number.isFinite(portNumber) ? `x${Math.max(portNumber - 1, 0)}` : 'xM';\n\nconst code = Number(event.message.code);\nconst hexCode = Number.isFinite(code) ? `0x${code.toString(16).toUpperCase()}` : '0x0';\n\nconst rawMode = (event.message.mode || '').toUpperCase();\nconst eventState = rawMode === 'APPEARS' ? 'event_start'\n  : rawMode === 'DISAPPEARS' ? 'event_stop'\n  : 'unknown';\n\nconst rawDeviceTimestamp = event.time ?? event.timestamp ?? event.timeStamp ?? null;\n\nmsg.topic = `impact67/master/${Number.isFinite(masterNumber) ? masterNumber : 'unknown'}/port/${portTag}`;\nmsg.timestamp = Date.now();\n\nconst description = errorMap[code] || errorMap[hexCode] || 'Unknown code';\n\nmsg.payload = {\n  severity: event.severity,\n  mode: rawMode,\n  eventState,\n  errorCode: Number.isFinite(code) ? code : null,\n  errorCodeHex: hexCode,\n  errorDescription: description,\n  master: masterNumber,\n  port: portTag,\n  isoTime: new Date(msg.timestamp).toISOString(),\n  rawDeviceTimestamp,\n  ip: msg.ip || 'unknown'\n};\n\nreturn msg;\n",
        "outputs": 1,
        "timeout": "",
        "noerr": 0,
        "initialize": "",
        "finalize": "",
        "libs": [],
        "x": 1520,
        "y": 160,
        "wires": [
            []
        ],
        "info": "**Description:** Alternate enrichment function for gateway events retained for backwards compatibility.\n**Inputs:** Accepts gateway event payloads and uses the global error map.\n**Outputs:** Returns the enriched message (no downstream wires at present).\n**Usage Notes:** Safe location for staging schema changes before reconnecting to the main pipeline."
    },
    {
        "id": "28500336b4ee8595",
        "type": "influxdb",
        "hostname": "127.0.0.1",
        "port": 8086,
        "protocol": "http",
        "database": "database",
        "name": "InfluxDB",
        "usetls": false,
        "tls": "",
        "influxdbVersion": "2.0",
        "url": "http://localhost:8086",
        "timeout": 10,
        "rejectUnauthorized": true,
        "info": "**Description:** Connection profile for the InfluxDB 2.x instance used by this project.\n**Inputs:** None (configuration node).\n**Outputs:** Referenced by all Influx-related nodes.\n**Usage Notes:** Update host, port, or authentication tokens here when moving between environments."
    },
    {
        "id": "mqtt-broker-local",
        "type": "mqtt-broker",
        "name": "Local MQTT",
        "broker": "localhost",
        "port": "1883",
        "clientid": "",
        "autoConnect": true,
        "usetls": false,
        "protocolVersion": 4,
        "keepalive": "60",
        "cleansession": true,
        "autoUnsubscribe": true,
        "birthTopic": "",
        "birthQos": "0",
        "birthRetain": "false",
        "birthPayload": "",
        "birthMsg": {},
        "closeTopic": "",
        "closeQos": "0",
        "closeRetain": "false",
        "closePayload": "",
        "closeMsg": {},
        "willTopic": "",
        "willQos": "0",
        "willPayload": "",
        "willMsg": {},
        "userProps": "",
        "sessionExpiry": "",
        "info": "**Description:** MQTT broker configuration for local development.\n**Inputs:** None (configuration node).\n**Outputs:** Provides connection details to MQTT In nodes.\n**Usage Notes:** Update host/port or credentials before deploying to staged or production brokers."
    }
]